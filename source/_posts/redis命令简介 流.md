---
title: redis命令简介 流
date: 2020-07-08 13:27:45
categories: redis
index_img: /img/articles/redis.jpg
tags:
	- redis
	- 流
	- stream
---

# 流

流（`stream`）是`redis 5.0`版本中新增的数据结构。**`stream`是一个新的强大的支持多播的可持久化的消息队列**，`stream`的设计借鉴了`kafka`  的设计

`stream`有一个消息的链表，将所有的加入消息都串连起来，每个消息都有唯一的`ID`和对应的内容。消息都是持久化的，`redis`重启后，消息依然存在。

每个`stream`都有唯一的名称，即`stream`的`key`

每个`stream`都可以挂载多个消费组（`consumer group`）。每个消费组都会有个游标`last_delivered_id`，在`stream`的消息链表上往前移动，表示当前此消费组已经消费到了哪一条消息。

每个消费组的状态都是独立的，互相不受影响，即同一份`stream`内部的消息都可以被每一个消费组消费到。

同一个消费组可以挂载多个消费者（`consumer`），这些消费者之间是竞争的关系，任意一个消费者读取了消息，都会使得该消费组的游标`last_delivered_id`往前移动。

消费者内部会有一个状态变量`pending_ids`，该状态变量记录了当前已经被客户端读取，但是还没有`ack`的消息。如果客户端没有`ack`，此状态变量里面的消息将越来越多。一旦某个消息被`ack`，则状态变量里的消息将变少。这个状态变量被`redis`官方称为`pending entries list`，用来确保客户端至少消费了消息一次，而不会在网络传输的过程中丢失了。



在以往的版本中，为了实现消息队列，用户往往会使用列表、有序集合、发布与订阅这三种功能，但是这些功能都有其缺陷：

1. 列表实现的消息队列虽然可以快速的将新的消息插入到列表中，但是列表为线性结构，查找消息需遍历整个列表，性能较低
2. 有序集合缺少列表、发布与订阅提供的阻塞弹出原语，使得程序无法利用有序集合去实现可阻塞的消息弹出操作
3. 发布与订阅的“发送即忘（`fire and forget`）”策略，使得离线的客户端会丢失消息，因此发布与订阅是无法实现可靠的消息队列
4. 列表、有序集合、订阅与发布实现的消息队列，如果需要在一条消息中传递多项信息，则需要JSON之类的序列化格式将多项信息打包到单个元素上，读取消息时还需反序列化操作

`stream`的出现就是为了解决以上的问题，是`redis`实现消息队列应用的最佳选择。

`stream`是一个包含任意多个`stream`元素的有序队列，队列中每个元素都包含一个`ID`和任意多键值对，这些元素会根据`ID`的大小在`stream`中有序地排列。

`stream`中的消息`ID`的形式为：`timestampInMillis-sequence`，比如`1527846880572-5`，其表示当前的消息在毫秒时间戳`1527846880572`时产生，并且是该毫秒内产生的第`5`条消息。

消息`ID`可以由服务器自动生成，也可以由客户端自己指定。但是形式必须是`整数-整数`，并且后加入的消息的`ID`需大于前面的消息的`ID`

通过将元素`ID`与时间相关联，并强制要求新元素的`ID`必须大于旧元素的`ID`，`redis`从逻辑上将`stream`变为一种只执行追加操作（`append only`）的数据结构，这种特性对于使用`stream`实现消息队列和事件系统的用户来说非常重要。用户可以确信，新的消息和事件只会出现在已有的消息和事件之后，就像现实世界中，新的事件总是发生在已有事件之后一样，一切都是有序进行的。

`stream`中的每个元素可以包含一个或者任意多个键值对，并且同一个`stream`中的不同元素可以包含不同数量的键值对。

`stream`中的元素会以有序的方式存储用户给定的键值对，即用户在创建元素时以什么顺序给定键值对，其被取出时也是什么样的顺序。



## xadd

**作用**：将带有指定`ID`以及包含指定键值对的元素追加到`stream`的末尾

**格式**：`xadd stream [MAXLEN len] id field value [field value ...]`

**扩展**：

如果给定的`stream`不存在，则命令会先创建一个空白的`stream`，然后将给定的元素添加到`stream`中

命令在成功执行后，将返回新元素的`ID`作为结果

在给定参数`id`时，还可以给出只包含毫秒时间的不完整的`id`，此时`redis`会自动将`id`的顺序编号设置为`0`

在`stream`中，对`id`的限制包括：

1. 同一个`stream`中各个元素的`ID`必须是各不相同的
2. 新元素的`ID`必须比`stream`中所有已有元素的`ID`都要大
3. 如果新元素`ID`的毫秒时间比最大`ID`的毫秒时间要大，则允许添加新元素
4. 如果新元素`ID`的毫秒时间与最大`ID`的毫秒时间相同，则对比顺序编号部分，如果新元素`ID`的顺序编号比最大`ID`的顺序编号大，则允许添加新元素

命令为参数`id`设定了一个特殊的值“`*`”，当用户将`*`作为`id`参数时，`redis`会自动为新添加的元素生成一个可用的新的`ID`，即自动生成的新的`ID`，会将`redis`所在的宿主机当前毫秒格式的`UNIX`时间戳用作`ID`的毫秒时间，并根据当前已有的`ID`的最大顺序编号来设置新的`ID`的顺序编号部分

如果用户使用了`*`作为`id`参数，但是宿主机的当前时间比`stream`中已有的最大`ID`的毫秒时间要小，则`redis`将使用该`ID`的毫秒时间作为新`ID`的毫秒时间，以此来避免机器时间倒流产生的错误

命令还提供了 `MAXLEN` 选项，使得用户在添加新元素的同时删除旧元素，以限制`stream`的最长长度，删除旧元素的原则是 `先进先出`



## xtrim

**作用**：直接将`stream`修剪至指定的长度

**格式**： `xtrim stream MAXLEN len`

**扩展**：

命令在执行后，返回被移除的元素的数量作为结果

命令根据 `先进先出` 的原则来淘汰旧元素



## xdel

**作用**：从`stream`中移除 `ID` 对应的元素

**格式**：`xdel stream id [id ...]`

**扩展**：

命令在成功执行后，返回被移除的元素的数量作为结果



## xlen

**作用**：获取`stream`目前包含的元素数量

**格式**：`xlen stream`

**扩展**：

如果给定的`stream`没有包含任何的元素，或者`stream`并不存在，则命令将返回`0`作为结果



## xrange & xrevrange

**作用**：访问`stream`中的元素

**格式**：

`xrange stream start_id end_id [COUNT n]`

`xrevrange stream end_id start_id [COUNT n]`

**扩展**：

`stream`本质上是一个有序序列，使用有序方式获取序列中各个元素是一种常见的操作。命令可以以遍历或者迭代的方式，访问`stream`中的单个或者任意多个元素

命令返回一个列表作为结果

如果将命令的起始 `ID` 和结束 `ID`设置为同一个`stream`元素的 `ID`，则命令就会从`stream`中获取并返回 `ID`指定的元素

如果将较小的元素 `ID`设置为命令的起始 `ID`，将较大的元素 `ID`设置为命令的结束 `ID`，则命令将从`stream`中获取从起始 `ID` 到结束 `ID`区间范围之内的所有元素

如果将命令的起始 `ID` 设置为 `-`，将命令的结束 `ID`设置为 `+`。则命令就会从`stream`中获取所有的元素

可以通过命令的 `COUNT` 选项限制一次命令调用可以返回的最大元素的数量

还可以使用命令对`stream`进行迭代，具体步骤为：

1. 使用 `-`作为起始 `ID`，使用 `+`作为结束 `ID`，调用带有 `COUNT`选项的命令，获取`stream`的前 `N`个元素
2. 对于命令返回的最后一个元素，将该元素的 `ID`的顺序部分加 `1`，得到一个新的 `ID`
3. 使用新的 `ID` 作为起始 `ID`，使用 `+` 作为结束 `ID`，继续调用带有 `COUNT`选项的命令
4. 重复步骤2和3，直到命令返回空列表为止。返回空列表表示整个`stream`已经被迭代完

`xrevrange`命令是 `xrange`命令的逆序版本，按照元素的 `ID`从大到小的顺序访问`stream`中的元素

**注意： `xrevrange`命令是先接受结束 `ID`，然后再接受起始`ID`**



## xread

**作用**：以阻塞或者非阻塞的方式获取`stream`元素

**格式**：`xread [BLOCK ms] [COUNT n] STREAMS stream1 stream2 ... id1 id2 ...`

**扩展**：

命令最基础的用法，是从多个给定的`stream`中获取大于指定 `ID`的多个元素，用户还可以通过可选参数 `COUNT`限制命令对于每个`stream`最多可以返回多少个元素

如果尝试使用命令去获取一个不存在的`stream`，或者给定的 `ID` 超过了`stream`中已有元素的最大 `ID`，则命令将返回一个 `nil`作为结果

命令也可以对一个或者多个`stream`进行迭代，具体步骤为：

1. 将表示`stream`起点的特殊的 `ID`，即 `0-0`（或者简写为`0`）作为 `ID`传入命令，并通过选项 `COUNT`读取`stream`开头的 `N`个元素
2. 使用命令返回的最后一个元素的 `ID`作为参数，再次调用带有 `COUNT`选项的命令
3. 重复执行步骤2，直到命令返回空值，或者命令返回元素的数量少于指定的数量为止

通过使用 `BLOCK`选项，并给定一个毫秒精度的超时时间作为参数，用户可以以阻塞的方式执行命令

`BLOCK`选项的值可以是任何大于等于 `0` 的数值，如果等于 `0`，表示阻塞直到出现可以返回的元素为止

如果我们需要从当前时刻开始，获取`stream`中新出现的元素，即我们想要“监听”指定的`stream`，并在这些`stream`出现新的元素时返回这些元素。一种解决办法是，先使用 `xrevrange`命令获取`stream`当前的最后一个元素，然后将该元素的 `ID`作为输入，调用启用了阻塞功能的 `xread`命令来达到 `只获取新出现的元素`的目的。但是重复执行这样的操作非常的麻烦，并且可能引发竞争条件。

为了解决以上的问题，`redis`为 `xread`命令提供了特殊的 `ID`参数，即 `$`符号，用户在执行阻塞式的命令时，命令就会只获取给定`stream`在命令执行之后新出现的元素，命令格式为：

`xread BLOCK ms STREAMS stream1 stream2 ... $ $ ...`



## xgroup

命令`xgroup`的作用，是管理消费者组，具有多个子命令。

 ### 创建消费者组

**作用**：为`stream`创建一个具有指定名字的消费者组

**格式**：`xgroup CREATE stream group id`

**扩展**：

参数`id`指定了消费者组的最后传递消息 `ID`，这个 `ID`限制了消费者能够接收到的消息范围。即消费者组属下的消费者只能接受到 `ID`大于最后传递消息 `ID`的消息，并且消费者组的最后传递消息 `ID`还会随着消费者执行的读取操作而不断更新

如果命令给定的`stream`不存在，则命令将返回一个错误

如果命令成功执行，则返回 `OK`

### 修改消费者组的最后传递消息ID

**作用**：对于一个已经存在的消费者组，通过命令为消费者组设置新的最后传递消息 `ID`

**格式**：`xgroup SETID stream group id`

**扩展**：

命令给定的 `ID`可以是任意合法的消息 `ID`，并且 `ID`对应的消息可以不存在，并且设置的新的 `ID`可以大于、小于、或者等于当前的 `ID`

除了合法的消息 `ID`以外，特殊的符号 `$`也可以作为参数 `id`的值，该特殊符号可以将消费者组的最后传递消息 `ID`设置为`stream`最新消息的 `ID`

**注意：命令会使得消费者可能漏掉一些原本应该读取的消息，或者使得消费者可能会重新读取之前已经被确认过的消息，因此，用户需谨慎使用该命令，并且只在不会引发错误的情况下使用该命令**



### 删除消费者

**作用**：删除消费者

**格式**：`xgroup DELCONSUMER stream group consumer`

**扩展**：

命令在执行后，返回一个数字，表示消费者在被删除时，仍在处理的消息数量

**需注意：当消费者被删除后，其被删除时处理的消息也会从消费者组的待处理消息队列中移除。即属于被删除的消费者的待处理消息将不再处于“待处理”状态，这些消息可能已经被消费者处理掉了，也可能尚未处理完成**

为了避免删除消费者时，其处理的消息还未妥善处理完毕，用户在删除一个消费者之前，应该确保传递给该消费者的所有消息已经处理完毕，或者使用`XCLAIM`命令显式地转移待处理消息的归属权

### 删除消费者组

**作用**：删除消费者组

**格式**：`xgroup DESTROY stream group`

**扩展**：

命令在成功执行删除操作后，返回 `1`

若被删除的消费者组不存在，则命令返回 `0`

**注意：为了保证程序的正确性，用户需确保在删除消费者组时，组中已经没有任何待处理的消息，否则这些待处理的消息可能无法得到妥善的处理**



## xreadgroup

**作用**：读取消费者组中的消息

**格式**：

`xreadgroup GROUP group consumer [COUNT n] [BLOCK ms] STREAMS stream [stream ...] id [id ...]`

**扩展**：

命令中的参数 `GROUP` 用于指定消费者组合消费者，通过此参数，说明想要读取的消费者组，以及执行该操作的消费者

命令在读取消息的同时，还会将该消息分别添加到消费者组的待处理消息队列，以及消费者的待处理消息队列中，从而使得被读取的消息的状态从原来的“未传递”转变为“待处理”，命令还会将最后一条被读取的消息的 `ID`设置为消费者组的最后传递消息 `ID`

在介绍`xread`命令时，介绍了可以将`id`参数设置为`$`，在不知道最后一条消息的情况下，获取最新出现的消息。而`xreadgroup`命令可以将 `id`参数设置为特殊符号`>`，命令将自动向消费者返回尚未传递的新消息



## xpending

**作用**：获取指定的 `stream`的指定消费者组目前的待处理消息的相关信息

**格式**：`xpending stream group [start stop count] [consumer]`

**扩展**：

命令返回的信息包括：

1. 待处理的消息数量
2. 待处理消息队列中的首条消息 `ID`
3. 待处理消息队列中的最后一条消息 `ID`
4. 消费者组名下各个消费者正在处理的消息数量，没有在处理消息的消费者将被忽略

参数`start`与`stop`用于指定消息的 `ID`范围

参数`count`用于限制被检阅的消息数量

## xack

**作用**：将消费者组中的指定的消息标记为“已处理”

**格式**：`xack stream group id [id ...]`

**扩展**：

被标记的消息将从当前的消费者的待处理消息队列中移除，而之后执行的`xreadgroup`命令将不会读取到这些消息

命令在执行后，将返回被标记的消息数量作为结果



## xclaim

**作用**：将指定的消息归属权从一个消费者转移到另一个消费者

**格式**： `xclaim stream group new_consumer max_pending_time id [id ...] [JUSTID]`

**扩展**：

命令中的参数 `stream`指定了消息所在的流

命令中的参数 `group`指定了消息所在的消费者组

命令中的参数 `new_consumer`指定了消息的新消费者

命令中的多个参数 `id`指明了需要转移归属权的消息

命令中的毫秒格式的参数 `max_pending_time`指定了执行归属权转移操作所需要的最大消息处理时限。具体为：

1. 如果命令执行的时候，消息原来的消费者用在处理该消息上的时间超过了指定的时限，则归属权转移操作就会被执行
2. 如果命令执行的时候，消息原来的消费者用在处理该消息上的时间未超过了指定的时限，或者该消息已经被原消费者确认，则归属权转移操作将放弃执行

命令在成功执行后，将返回被转移的消息作为结果

如果命令未成功执行，则将返回一个空列表

默认情况下，命令将返回被转移的消息的 `ID`以及其内容，指定可选的参数 `JUSTID`，可以让命令只返回被转移的消息 `ID`，这样可以减少不必要的数据传输，减少带宽消耗



## xinfo

`redis`提供了 `xinfo`命令，用于查看 `stream`及其消费者组的相关信息，该命令具有多个子命令

### 打印消费者信息

**作用**：打印指定的消费者组中的所有消费者，以及这些消费者的相关信息

**格式**：`xinfo CONSUMERS stream group-name`

**扩展**：

命令打印的信息包括消费者的名字，消费者正在处理的消息数量，以及消费者的闲置时长（毫秒格式）



### 打印消费者组信息

**作用**：打印与给定的 `stream`相关联的所有消费者组的信息

**格式**：`xinfo GROUPS stream`

**扩展**：

命令打印的信息包括消费者组的名字，其拥有的消费者数量，消费者组中正在处理消息的数量，以及消费者组最后传递的消息 `ID`



### 打印流信息

**作用**：打印给定的 `stream`相关信息

**格式**：`xinfo STREAM stream`

**扩展**：

命令打印的信息包括`stream`的长度，`stream`在底层的基数树表示的相关信息，`stream`相关的消费者组数量，`stream`最后生成的消息 `ID`，`stream`的第一个节点和最后一个节点