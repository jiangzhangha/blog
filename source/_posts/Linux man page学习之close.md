---
title: Linux man page学习之close
date: 2020-07-29 10:43:00
categories: Linux知识
index_img: /img/articles/close.jpg
tags:
	- Linux
	- close
---

本文简介了类UNIX系统下（主要为Linux）的close相关函数的内容。

<!-- more -->

# 函数原型

~~~c
#include <unistd.h>

int close(int fd);
~~~

# 简介

close()系统调用将关闭一个文件描述符，这样该文件描述符将不再指向任何的文件。且该文件描述符将被返回给内核重复使用。随后的其他进程可能通过open()系统调用获取到同样数值的文件描述符，此时该文件描述符将指向不同的文件。

当调用close()系统调用后，文件描述符上的记录锁将被释放。

# 返回值

若成功，将返回0

若失败，将返回-1，且设置errno

# 其他

## 数据刷新

当内核使用高速缓存推迟实际的write操作时，一个成功的close()系统调用并不能保证数据一定是成功被写入到磁盘中。通常当一个文件被close时，文件系统并不会将缓存数据刷新到磁盘文件中。如果需要保证文件在被close之前，数据已经存储到磁盘，则在close之前使用fsync()系统调用。

## 多线程竞争

在多线程的程序中，可能被某一个线程close的文件描述符，在另一个线程中正在被使用。特别是文件描述符会被重复使用，因此这样会带来意想不到的结果。

考虑以下的场景：

1. 一个线程对某个文件描述符进行IO操作时被阻塞；
2. 此时，另一个线程关闭了该文件描述符。

对于以上的场景，在不同的类UNIX系统中将会有不同的结果。

在某些系统中，当文件描述符被关闭，被阻塞的IO操作将立马返回错误。

而在Linux系统中，被阻塞的IO操作将不会立马返回错误，而是一直阻塞至调用的成功完成。

## 返回值处理

既然可能会失败，一个小心的程序员将会检查 close()系统调用的返回值。若未检查返回值，则可能导致数据的丢失，特别是在NFS文件系统中。

对于close()系统调用的错误处理，一般是给出警告，即数据可能会丢失，或者是立马对文件再进行一次write操作，或者是创建一个备份文件。

需要注意：**对一个执行close()系统调用失败的文件，再次执行close()系统调用，是错误的**。因为执行close()系统调用后，文件描述符将会被重复使用，因此再次执行close()系统调用，可能会close掉正在使用的文件描述符。