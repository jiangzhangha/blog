---
title: 为什么size_t重要？
date: 2020-07-08 14:00:00
categories: Linux知识
index_img: /img/articles/linux.jpg
tags:
	- Linux
	- 杂谈
---

# 为什么size_t重要？

> 本文摘录自：https://jeremybai.github.io/blog/2014/09/10/size-t

## 前言

使用size_t可能会提高代码的可移植性，有效性，或者可读性。

在标准C库中，许多函数使用的参数，或者返回值都是用字节大小表示的对象大小，比如malloc(n)函数的参数n表示需要申请的内存空间的字节大小，再比如memcpy(s1, s2, n)，函数的最后一个参数n表示需要复制的内存的大小。

或许你认为这些参数或者返回值应该被声明为int类型，或者long类型，但是事实上，在C标准中将其定义为size_t类型，比如下列的函数声明：

~~~c
void *malloc(size_t n);
void *memcpy(void *s1, void const *s2, size_t n);
size_t strlen(char const *s);
~~~

类似size_t还出现在C++标准库中，此外C++标准库中还经常使用一个类似的类型size_type。

## 可移植性问题

在早期的C语言中并没有提供size_t类型，C标准委员会为了解决移植性问题，将size_t引入到C语言中。

比如，让我们写一个可移植的memcpy函数，将会看到一些不同的声明和它们在不同的平台下的编译情况。

对于memcpy(s1, s2, n)函数，其将s2指向的地址开始的n个字节拷贝到s1指向的地址，返回s1，这个函数可以拷贝任意类型的数据，所以参数与返回值类型为void *类型。对于第三个参数n，代表了源对象的大小，若将其类型写为int，即：

~~~c
void *memcpy(void *s1, void const *s2, int n);
~~~

使用int类型在大部分情况下都是可以的，但是并不是所有情况下都可以。int是有符号的，它可以表示负数，但是，大小不可能是复数。所以我们可以使用unsigned int代替它让第三个参数表示的范围更大。

在大部分机器上，unsigned int的最大值要比int的最大值大两倍，比如说再也给16位的机器上，unsigned int的最大值为65535，int的最大值为32767。

尽管int类型的大小依赖于C编译器的实现，但是在给定的平台上int对象的大小和unsigned int对象的大小是一样的。因此，使用unsigned int修饰第三个参数的代价与int是相同的：

~~~c
void *memcpy(void *s1, void const *s2, unsigned int n); 
~~~

这样似乎没有问题了，unsigned int可以表示最大类型的对象大小了，这种情况只有在整形和指针类型具有相同大小的情况下，比如说在IP16中，整形和指针都占2个字节（16位），而在IP32上面，整形和指针都占4个字节（32位）。

不幸的是，这种memcpy的申明在I16LP32架构上（整形是16-bit 长整形和指针类型时32-bits）显得不够用了，比如说摩托罗拉第一代处理器68000，在这种情况下，处理器可能拷贝的数据大于65535个字节，但是这个函数第三个参数n不能处理这么大的数据。

什么？你说很容易就可以改正？只需要把memcpy的第三个参数的类型修改一下：

~~~c
void *memcpy(void *s1, void const *s2, unsigned long  n); 
~~~

你可以在I16LP32目标架构上使用这个函数了，它可以处理更大的数据。而且在IP16和IP32平台上效果也还行，说明它确实给出了memcpy的一种移植性较好的申明。但是，在IP16平台上相比于使用`unsigned int`，你使用`unsigned long`可能会使你的代码运行效率大打折扣（代码量变大而且运行变慢）。

在标准C中规定，长整形（无论无符号或者有符号）至少占用32位，因此在IP16平台上支持标准C的话，那么它一定是IP16L32 平台。这些平台通常使用一对16位的字来实现32位的长整形。在这种情况下，移动一个长整形需要两条机器指令，每条移动一个16位的块。事实上，这个平台上的大部分的32位操作都需要至上两条指令。

因此，以可移植性为名将memcpy的第三个参数申明为unsigned long而降低某些平台的性能是我们所不希望看到的。使用size_t可以有效避免这种情况。

size_t类型是一个类型定义，通常将一些无符号的整形定义为size_t，比如说unsigned int或者unsigned long，甚至unsigned long long。每一个标准C实现应该选择足够大的无符号整形来代表该平台上最大可能出现的对象大小。

## 使用size_t

size_t的定义在`<stddef.h>, <stdio.h>, <stdlib.h>, <string.h>, <time.h>和<wchar.h>`这些标准C头文件中，也出现在相应的C++头文件中，在使用size_t之前，你应该在你的头文件中至少包含一个这样的头文件。

包含以上任何C头文件（由C或C++编译的程序）表明将size_t作为全局关键字。包含以上任何C++头文件（当你只能在C++中做某种操作时）表明将size_t作为std命名空间的成员。

根据定义，size_t是sizeof关键字（注：sizeof是关键字，并非运算符）运算结果的类型。所以，应当通过适当的方式声明n来完成赋值：

~~~c
size_t n = sizeof(thing);
~~~

适当地使用size_t还会使你的代码变得如同自带文档。当你看到一个对象声明为size_t类型，你马上就知道它代表字节大小或数组索引，而不是错误代码或者是一个普通的算术值。







